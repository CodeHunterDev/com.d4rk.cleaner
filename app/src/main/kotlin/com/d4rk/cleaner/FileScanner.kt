package com.d4rk.cleanerimport android.annotation.SuppressLintimport android.content.Contextimport android.content.SharedPreferencesimport android.content.pm.PackageManagerimport android.content.res.Resourcesimport android.graphics.Colorimport android.widget.TextViewimport androidx.preference.PreferenceManagerimport com.d4rk.cleaner.databinding.ActivityMainBindingimport java.io.Fileimport java.util.Localeimport kotlin.collections.ArrayListimport kotlin.collections.HashSetclass FileScanner(private val path: File, context: Context?) {    private var prefs: SharedPreferences? = context?.let {        PreferenceManager.getDefaultSharedPreferences(it)    }    private var context: Context? = null    private var res: Resources? = null    private var gui: ActivityMainBinding? = null    private var filesRemoved = 0    private var kilobytesTotal: Long = 0    private var delete = false    private var emptyDir = false    private var autoWhite = true    private var corpse = false    private val listFiles: List<File> get() = getListFiles(path)    private fun getListFiles(parentDirectory: File): List<File> {        val inFiles = ArrayList<File>()        val files = parentDirectory.listFiles()        if (files != null) {            for (file in files) {                if (file != null) {                    if (!isWhiteListed(file)) {                        if (file.isDirectory) {                            if (autoWhite) {                                if (!autoWhiteList(file)) inFiles.add(file)                            } else inFiles.add(file)                            inFiles.addAll(getListFiles(file))                        } else inFiles.add(file)                    }                }            }        }        return inFiles    }    private fun isWhiteListed(file: File): Boolean {        for (path in WhitelistActivity.getWhiteList(prefs)) when {            path.equals(file.absolutePath, ignoreCase = true) || path.equals(file.name, ignoreCase = true) -> return true        }        return false    }    private fun autoWhiteList(file: File): Boolean {        protectedFileList.forEach { protectedFile ->            if (file.name.lowercase(Locale.getDefault()).contains(protectedFile) &&                !WhitelistActivity.getWhiteList(prefs)                    .contains(file.absolutePath.lowercase(Locale.getDefault()))            ) {                WhitelistActivity.getWhiteList(prefs).toMutableList().add(file.absolutePath.lowercase(Locale.getDefault()))                prefs?.edit()?.putStringSet("whitelist", HashSet(WhitelistActivity.getWhiteList(prefs)))?.apply()                return true            }        }        return false    }    fun filter(file: File?): Boolean {        if (file != null) {            try {                when {                    corpse && file.parentFile != null && file.parentFile.parentFile != null && file.parentFile.name == "data" && file.parentFile.parentFile.name == "Android" && file.name != ".nomedia" && !installedPackages.contains(file.name) -> return true                }                if (file.isDirectory && isDirectoryEmpty(file) && emptyDir) return true                val filterIterator = filters.iterator()                while (filterIterator.hasNext()) {                    val filter = filterIterator.next()                    if (file.absolutePath.lowercase(Locale.getDefault()).matches(filter.lowercase(Locale.getDefault()).toRegex()))                        return true                }            } catch (e: NullPointerException) {                return false            }        }        return false    }    private val installedPackages: List<String>        get() {            val pm = context!!.packageManager            val packages = pm.getInstalledApplications(PackageManager.GET_META_DATA)            val packagesString: MutableList<String> = ArrayList()            for (packageInfo in packages) {                packagesString.add(packageInfo.packageName)            }            return packagesString        }    private fun isDirectoryEmpty(directory: File): Boolean {        return if (directory.list() != null && directory.list() != null) directory.list().isEmpty()        else false    }    @SuppressLint("ResourceType")    fun setUpFilters(generic: Boolean, aggressive: Boolean,  true_aggressive: Boolean, apk: Boolean): FileScanner {        val folders: MutableList<String> = ArrayList()        val files: MutableList<String> = ArrayList()        setResources(context!!.resources)        if (generic) {            folders.addAll(listOf(*res!!.getStringArray(R.array.generic_filter_folders)))            files.addAll(listOf(*res!!.getStringArray(R.array.generic_filter_files)))        }        if (true_aggressive) {            folders.addAll(listOf(*res!!.getStringArray(R.array.true_aggressive_filter_folders)))            files.addAll(listOf(*res!!.getStringArray(R.array.true_aggressive_filter_files)))        }        if (aggressive) {            folders.addAll(listOf(*res!!.getStringArray(R.array.aggressive_filter_folders)))            files.addAll(listOf(*res!!.getStringArray(R.array.aggressive_filter_files)))        }        filters.clear()        for (folder in folders) filters.add(getRegexForFolder(folder))        for (file in files) filters.add(getRegexForFile(file))        if (apk) filters.add(getRegexForFile(".apk"))        return this    }    fun startScan(): Long {        isRunning = true        var cycles: Byte = 0        var maxCycles: Byte = 1        var foundFiles: List<File>        if (prefs?.getBoolean("multirun", false) == true) maxCycles = 10        if (!delete) maxCycles = 1        while (cycles < maxCycles) {            if (gui != null) (context as MainActivity?)!!.displayText("Running Cycle" + " " + (cycles + 1) + "/" + maxCycles)            foundFiles = listFiles            if (gui != null) gui!!.scanProgress.max = gui!!.scanProgress.max + foundFiles.size            var tv: TextView? = null            for (file in foundFiles) {                if (filter(file)) {                    if (gui != null) tv = (context as MainActivity?)!!.displayDeletion(file)                    kilobytesTotal += file.length()                    if (delete) {                        ++filesRemoved                        if (!file.delete() && tv != null) {                            (context as MainActivity?)!!.runOnUiThread {                                tv.setTextColor(Color.GRAY)                            }                        }                    }                }                if (gui != null) {                    (context as MainActivity?)!!.runOnUiThread {                        gui!!.scanProgress.progress = gui!!.scanProgress.progress + 1                    }                    val scanPercent = gui!!.scanProgress.progress * 100.0 / gui!!.scanProgress.max                    (context as MainActivity?)!!.runOnUiThread {                        gui!!.scanTextView.text = String.format(Locale.US, "%.0f", scanPercent) + "%"                        gui!!.statusTextView.text = context!!.getString(R.string.main_status_running) + " " + String.format(Locale.US, "%.0f", scanPercent) + "%"                    }                }            }            if (gui != null) (context as MainActivity?)!!.displayText("Finished Cycle" + " " + (cycles + 1) + "/" + maxCycles)            if (filesRemoved == 0) break            filesRemoved = 0            ++cycles        }        isRunning = false        return kilobytesTotal    }    private fun getRegexForFolder(folder: String): String {        return ".*(\\\\|/)$folder(\\\\|/|$).*"    }    private fun getRegexForFile(file: String): String {        return ".+" + file.replace(".", "\\.") + "$"    }    fun setGUI(gui: ActivityMainBinding?): FileScanner {        this.gui = gui        return this    }    fun setResources(res: Resources?): FileScanner {        this.res = res        return this    }    fun setEmptyDir(emptyDir: Boolean): FileScanner {        this.emptyDir = emptyDir        return this    }    fun setDelete(delete: Boolean): FileScanner {        this.delete = delete        return this    }    fun setCorpse(corpse: Boolean): FileScanner {        this.corpse = corpse        return this    }    fun setAutoWhite(autoWhite: Boolean): FileScanner {        this.autoWhite = autoWhite        return this    }    fun setContext(context: Context?): FileScanner {        this.context = context        return this    }    companion object {        @JvmField        var isRunning = false        private val filters = ArrayList<String>()        private val protectedFileList = arrayOf("backup", "copy", "copies", "important", "do_not_edit", "bak")    }    init {        WhitelistActivity.getWhiteList(prefs)    }}