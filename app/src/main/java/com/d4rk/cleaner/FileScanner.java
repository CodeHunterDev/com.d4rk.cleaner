package com.d4rk.cleaner;import static com.d4rk.cleaner.WhitelistActivity.getWhiteList;import android.content.Context;import android.content.SharedPreferences;import android.content.pm.ApplicationInfo;import android.content.pm.PackageManager;import android.content.res.Resources;import android.graphics.Color;import android.preference.PreferenceManager;import android.widget.TextView;import com.d4rk.cleaner.databinding.ActivityMainBinding;import java.io.File;import java.util.ArrayList;import java.util.Arrays;import java.util.HashSet;import java.util.List;import java.util.Locale;import java.util.Objects;public class FileScanner {    public static boolean isRunning = false;    final SharedPreferences prefs;    private Context context;    private final File path;    private Resources res;    private ActivityMainBinding gui;    private int filesRemoved = 0;    private long kilobytesTotal = 0;    private boolean delete = false;    private boolean emptyDir = false;    private boolean autoWhite = true;    private boolean corpse = false;    private static final ArrayList < String > filters = new ArrayList < > ();    private static final String[] protectedFileList = {"backup", "copy", "copies", "important", "do_not_edit"};    public FileScanner(File path, Context context) {        this.path = path;        prefs = PreferenceManager.getDefaultSharedPreferences(context);        WhitelistActivity.getWhiteList();    }    private List < File > getListFiles() {        return getListFiles(path);    }    private synchronized List < File > getListFiles(File parentDirectory) {        ArrayList < File > inFiles = new ArrayList < > ();        File[] files = parentDirectory.listFiles();        if (files != null) {            for (File file: files) {                if (file != null) {                    if (!isWhiteListed(file) && file.isDirectory() && (autoWhite)) {                        if (!autoWhiteList(file))                            inFiles.add(file);                    } else inFiles.add(file);                    inFiles.addAll(getListFiles(file));                } else inFiles.add(null);            }        }        return inFiles;    }    private synchronized boolean isWhiteListed(File file) {        for (String path: getWhiteList())            if (path.equalsIgnoreCase(file.getAbsolutePath()) ||                    path.equalsIgnoreCase(file.getName()))                return true;        return false;    }    private synchronized boolean autoWhiteList(File file) {        for (String protectedFile: protectedFileList) {            if (file.getName().toLowerCase().contains(protectedFile) && !getWhiteList().contains(file.getAbsolutePath().toLowerCase())) {                getWhiteList().add(file.getAbsolutePath().toLowerCase());                prefs.edit().putStringSet("whitelist", new HashSet < > (getWhiteList())).apply();                return true;            }        }        return false;    }    public synchronized boolean filter(File file) {        try {            if (file != null) {                if (file.getParentFile() != null && file.getParentFile().getParentFile() != null && corpse && (file.getParentFile().getName().equals("data") && file.getParentFile().getParentFile().getName().equals("Android") && (!getInstalledPackages().contains(file.getName()) && !file.getName().equals(".nomedia")))) {                    return true;                }                if (file.isDirectory()) {                    if (isDirectoryEmpty(file) && emptyDir) return true;                }                for (String filter: filters)                    if (file.getAbsolutePath().toLowerCase()                            .matches(filter.toLowerCase()))                        return true;            }        } catch (NullPointerException e) {            return false;        }        return false;    }    private synchronized List < String > getInstalledPackages() {        final PackageManager pm = context.getPackageManager();        List < ApplicationInfo > packages = pm.getInstalledApplications(PackageManager.GET_META_DATA);        List < String > packagesString = new ArrayList < > ();        for (ApplicationInfo packageInfo: packages) {            packagesString.add(packageInfo.packageName);        }        return packagesString;    }    private synchronized boolean isDirectoryEmpty(File directory) {        if (directory.list() != null && directory.list() != null) return Objects.requireNonNull(directory.list()).length == 0;        else return false;    }    public synchronized FileScanner setUpFilters(boolean generic, boolean true_aggressive, boolean aggressive, boolean apk) {        List < String > folders = new ArrayList < > ();        List < String > files = new ArrayList < > ();        setResources(context.getResources());        if (generic) {            folders.addAll(Arrays.asList(res.getStringArray(R.array.generic_filter_folders)));            files.addAll(Arrays.asList(res.getStringArray(R.array.generic_filter_files)));        }        if (aggressive) {            folders.addAll(Arrays.asList(res.getStringArray(R.array.aggressive_filter_folders)));            files.addAll(Arrays.asList(res.getStringArray(R.array.aggressive_filter_files)));        }        if (true_aggressive) {            folders.addAll(Arrays.asList(res.getStringArray(R.array.true_aggressive_filter_folders)));            files.addAll(Arrays.asList(res.getStringArray(R.array.true_aggressive_filter_files)));        }        filters.clear();        for (String folder: folders)            filters.add(getRegexForFolder(folder));        for (String file: files)            filters.add(getRegexForFile(file));        if (apk) filters.add(getRegexForFile(".apk"));        return this;    }    public long startScan() {        FileScanner.isRunning = true;        byte cycles = 0;        byte maxCycles = 1;        List < File > foundFiles;        if (prefs.getBoolean("multirun", false)) maxCycles = 10;        if (!delete) maxCycles = 1;        while (cycles < maxCycles) {            if (gui != null)((MainActivity) context).displayText("Running Cycle" + " " + (cycles + 1) + "/" + maxCycles);            foundFiles = getListFiles();            if (gui != null) gui.scanProgress.setMax(gui.scanProgress.getMax() + foundFiles.size());            for (File file: foundFiles) {                if (filter(file)) { // Filter.                    TextView tv = null;                    if (gui != null) tv = ((MainActivity) context).displayDeletion(file);                    if (delete) {                        kilobytesTotal += file.length();                        ++filesRemoved;                        if (!file.delete()) { // Deletion.                            if (tv != null) {                                TextView finalTv = tv;                                ((MainActivity) context).runOnUiThread(() -> finalTv.setTextColor(Color.GRAY));                            }                        }                    } else {                        kilobytesTotal += file.length();                    }                }                if (gui != null) {                    ((MainActivity) context).runOnUiThread(() -> gui.scanProgress.setProgress(gui.scanProgress.getProgress() + 1));                    double scanPercent = gui.scanProgress.getProgress() * 100.0 / gui.scanProgress.getMax();                    ((MainActivity) context).runOnUiThread(() -> gui.scanTextView.setText(String.format(Locale.US, "%.0f", scanPercent) + "%"));                }            }            if (gui != null)((MainActivity) context).displayText("Finished Cycle" + " " + (cycles + 1) + "/" + maxCycles);            if (filesRemoved == 0) break;            filesRemoved = 0;            ++cycles;        }        FileScanner.isRunning = false;        return kilobytesTotal;    }    private String getRegexForFolder(String folder) {        return ".*(\\\\|/)" + folder + "(\\\\|/|$).*";    }    private String getRegexForFile(String file) {        return ".+" + file.replace(".", "\\.") + "$";    }    public FileScanner setGUI(ActivityMainBinding gui) {        this.gui = gui;        return this;    }    void setResources(Resources res) {        this.res = res;    }    public FileScanner setEmptyDir(boolean emptyDir) {        this.emptyDir = emptyDir;        return this;    }    public FileScanner setDelete(boolean delete) {        this.delete = delete;        return this;    }    public FileScanner setCorpse(boolean corpse) {        this.corpse = corpse;        return this;    }    public FileScanner setAutoWhite(boolean autoWhite) {        this.autoWhite = autoWhite;        return this;    }    public FileScanner setContext(Context context) {        this.context = context;        return this;    }}